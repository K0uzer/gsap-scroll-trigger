# gsap-scroll-trigger
gsap-scroll-trigger
ДОКУМЕНТАЦИЯ

Основные характеристики

1)ScrollTriggers могут выполнять действия с анимацией (воспроизведение, приостановка,
  возобновление, перезапуск, обратный, завершение, сброс) при входе / выходе из
  определенной области или связывать ее непосредственно с полосой прокрутки, чтобы она
  действовала как скруббер (scrub: true).
2)Смягчите связь между анимацией и полосой прокрутки, чтобы "наверстать упущенное"
  заняло определенное время, напримерscrub: 1, потребовалась бы одна секунда, чтобы
  наверстать упущенное.
3)Интегрирован с ScrollSmoother, инструментом плавной прокрутки GreenSock, построенным на
  собственной технологии прокрутки (только для пользователей).
4)Привязка к определенным точкам анимации в зависимости от скорости. На самом деле, вы
  можете getVelocity()прокручивать в любое время. Привязка к ближайшей метке на
  временной шкале или к значению прогресса в массиве или запуск собственной
  пользовательской логики на основе функций для привязки
5)Встраивайте триггеры прокрутки непосредственно в любую анимацию GSAP (включая
  временные рамки) или создавайте автономные экземпляры и подключайтесь к расширенной
  системе обратного вызова, чтобы делать все, что захотите.
6)Расширенные возможности закрепления могут блокировать элемент на месте между
  определенными позициями прокрутки. Дополнение добавляется автоматически, чтобы
  соответственно опускать другие элементы, поэтому они догоняют, когда элемент открепляется
  (отключите это с pinSpacing: falseпомощью ). Вы даже можете закрепить один и тот же
   элемент несколько раз в разных точках.
 7)Невероятная гибкость для определения позиций прокрутки - например, "начинается,
   когда центр этого элемента попадает в центр области просмотра, и заканчивается, когда
   нижняя часть другого элемента попадает в нижнюю часть области просмотра",
   используйте ключевые слова (вверху, по центру, внизу, слева, справа), проценты, пиксели или
   дажеотносительные значения, такие как "+=300px". Как только вы освоитесь с синтаксисом, он
   станет удивительно интуитивно понятным.
 8)Автоматически пересчитывает позиции при изменении размера окна.
 9)Включите визуальные маркеры во время разработки, чтобы точно видеть, где находятся
   начальные / конечные / триггерные точки. Вариантов настройки предостаточно,
   напримерmarkers: {startColor: "green", endColor: "red", fontSize: "12px"}.
 10)Переключение класса CSS. Например, toggleClass: "active"добавляет "активный" класс к
   элементу триггера, пока ScrollTrigger активен. Вы также можете влиять на другие элементы.
 11)Адаптивный - используйте метод matchMedia() для создания различных настроек для
   различных размеров экрана с использованием стандартных медиа-запросов.
 12)Пользовательские контейнеры - вам не нужно использовать область просмотра; вместо этого
   определите пользовательский скроллер, например <div> .
 
 Простой пример: 
  gsap.to (".box", {
   scrollTrigger: ".box", // запустите анимацию, когда ".box" появится в окне просмотра (один раз)
   x: 500
  });
 
Расширенный пример
 let tl  = gsap.timeline({
    // да, мы можем добавить его на всю временную шкалу!
 scrollTrigger: {
 trigger: ".container",
 pin: true,   // закрепите элемент триггера, пока он активен
 start: "top top", // когда верхняя часть триггера попадает в верхнюю часть окна просмотра
      end:  "+=500", // завершается после прокрутки на 500 пикселей дальше начала
 scrub:  1, // плавная очистка, требуется 1 секунда, чтобы "догнать" полосу прокрутки
:  {
 snapTo: "labels", // привязка к ближайшей метке на временной шкале
 duration:  {min:  0,2, max:  3}, // анимация привязки должна длиться не менее 0,2 секунды, но не более 3 секунд (определяется скоростью)
 delay:  0,2, // подождите 0,2 секунды с момента последнего события прокрутки, прежде чем выполнять привязку: "power1.inOut" // простота анимации привязки (по умолчанию "power3")
      }
    }
  });

// добавление анимации и надписей на временную шкалу
tl.addLabel("start")
  .from(".box p", {scale:  0.3, rotation: 45, autoAlpha:  0})
  .addLabel("color")
  .from(".box", {backgroundColor: "#28a92b"})
  .addLabel("spin")
  .to(".box", {rotation:  360})
  .addLabel("end");

Автономный / Пользовательский пример
Вам не нужно помещать ScrollTriggers непосредственно в анимацию (хотя это, вероятно, 
наиболее распространенный вариант использования). Используйте обратные вызовы для чего угодно...
 ScrollTrigger.create({
  trigger: "#id",
  start: "top top",
  endTrigger: "#otherID",
  end: "bottom 50%+=100px",
  onToggle: self => console.log("toggled, isActive:", self.isActive),
  onUpdate: self => {
    console.log("progress:", self.progress.toFixed(3), "direction:", self.direction, "velocity", self.getVelocity());
  }
});
 
Использование и специальные свойства
scrollTrigger может использоваться либо как сокращение для trigger(описанного ниже), либо как объект конфигурации с любым из следующих свойств:

animation - экземпляр GSAP Tween или Timeline. Для каждого ScrollTrigger управляется только одна анимация, но вы можете
            поместить все свои анимации на одну временную шкалу (лучше всего) или создать
            несколько SCROLLTRIGGER, если хотите.

anticipatePin - 





















 
 
 
